<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HVATP Sender - File Transfer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
            overflow: visible; /* Allow QR code to show fully */
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
        }

        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-section:hover {
            background: #f8f9ff;
            border-color: #764ba2;
        }

        .upload-section.dragover {
            background: #f0f2ff;
            border-color: #764ba2;
            transform: scale(1.02);
        }

        #fileInput {
            display: none;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 20px;
        }

        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .setting-group {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
        }

        .setting-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
        }

        .setting-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
        }

        .setting-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            font-weight: 600;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .display-area {
            background: #000;
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
            display: none;
            position: relative;
            min-height: 600px; /* Larger minimum to accommodate QR code */
            max-height: none; /* Remove height restriction */
            overflow: visible; /* Don't clip the canvas */
            text-align: center; /* Center the canvas */
        }

        .display-area.active {
            display: block;
        }

        #qrDisplay {
            /* Don't set width/height in CSS - let JavaScript control canvas size */
            /* JavaScript sets BOTH canvas.width/height AND style.width/height */
            margin: 0 auto;
            display: block;
            /* Prevent blurriness on scaled images */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
            -ms-interpolation-mode: nearest-neighbor;
        }

        .stats {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }

        .stats.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        @media (max-width: 600px) {
            .container {
                border-radius: 0;
            }

            .content {
                padding: 20px;
            }

            .settings {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì° HVATP Sender</h1>
            <p>Hybrid Visual + Audio Transfer Protocol</p>
        </div>

        <div class="content">
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìÅ</div>
                <h2>Drop your file here or click to browse</h2>
                <p>Any file type supported</p>
                <input type="file" id="fileInput">
            </div>

            <div class="settings">
                <div class="setting-group">
                    <label for="encodingMode">Encoding Mode</label>
                    <select id="encodingMode">
                        <option value="HIGH_DENSITY">High Density (8 colors)</option>
                        <option value="BALANCED" selected>Balanced (4 colors)</option>
                        <option value="ROBUST">Robust (B&W)</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label for="errorCorrection">Error Correction</label>
                    <select id="errorCorrection">
                        <option value="0.25">Low (25%)</option>
                        <option value="0.35" selected>Medium (35%)</option>
                        <option value="0.50">High (50%)</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label for="frameRate">Frame Rate</label>
                    <select id="frameRate">
                        <option value="15">15 fps (Slow)</option>
                        <option value="30" selected>30 fps (Normal)</option>
                        <option value="60">60 fps (Fast)</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label for="audioChannel">
                        <input type="checkbox" id="audioChannel" checked style="width: auto; margin-right: 10px;">
                        Enable Audio Channel (Sync + Metadata)
                    </label>
                </div>

                <div class="setting-group">
                    <label for="loopMode">
                        <input type="checkbox" id="loopMode" checked style="width: auto; margin-right: 10px;">
                        Loop Mode (Repeat frames continuously)
                    </label>
                </div>
            </div>

            <div style="text-align: center;">
                <button class="btn" id="startBtn" disabled>Start Transfer</button>
            </div>

            <div class="stats" id="stats">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="frameCount">0</div>
                        <div class="stat-label">Frames</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="fileSize">0 KB</div>
                        <div class="stat-label">File Size</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="throughput">0 KB/s</div>
                        <div class="stat-label">Throughput</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="progress">0%</div>
                        <div class="stat-label">Progress</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="loopCounter">0</div>
                        <div class="stat-label">Loops</div>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
            </div>

            <div class="display-area" id="displayArea">
                <canvas id="qrDisplay"></canvas>
                <div class="controls">
                    <button class="btn" id="pauseBtn">‚è∏ Pause</button>
                    <button class="btn" id="stopBtn">‚èπ Stop</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simple QR-like encoder (simplified version)
        class SimpleVisualEncoder {
            constructor(mode = 'BALANCED', eccLevel = 0.35) {
                this.mode = mode;
                this.eccLevel = eccLevel;
                this.moduleCount = 100; // Reduced from 150 for better performance
                this.colors = this.getColorPalette();
            }

            getColorPalette() {
                const palettes = {
                    'HIGH_DENSITY': ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'],
                    'BALANCED': ['#000000', '#FFFFFF', '#FF0000', '#0000FF'],
                    'ROBUST': ['#000000', '#FFFFFF']
                };
                return palettes[this.mode];
            }

            encodeFrame(data, frameId, totalFrames) {
                const canvas = document.createElement('canvas');
                const moduleSize = 4;
                canvas.width = this.moduleCount * moduleSize;
                canvas.height = this.moduleCount * moduleSize;
                
                console.log(`üèóÔ∏è Creating source canvas: moduleCount=${this.moduleCount}, moduleSize=${moduleSize}, canvas=${canvas.width}x${canvas.height}`);
                
                const ctx = canvas.getContext('2d');
                
                // TEST: Fill entire canvas with a color to see if it's all there
                ctx.fillStyle = '#00FF00'; // Green background
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                console.log(`‚úÖ Filled green rect from (0,0) to (${canvas.width},${canvas.height})`);

                // Use ImageData for faster pixel manipulation
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const pixels = imageData.data;

                // Pre-convert colors to RGB
                const colorRGB = this.colors.map(c => {
                    const r = parseInt(c.substr(1, 2), 16);
                    const g = parseInt(c.substr(3, 2), 16);
                    const b = parseInt(c.substr(5, 2), 16);
                    return [r, g, b];
                });

                // Calculate bits per module based on color count
                const bitsPerModule = Math.log2(this.colors.length);
                const modulesNeeded = Math.ceil((data.length * 8) / bitsPerModule);

                // Convert data to bits (works with Uint8Array or string)
                let bitString = '';
                for (let i = 0; i < data.length; i++) {
                    const byte = data[i]; // Direct byte access for Uint8Array
                    bitString += byte.toString(2).padStart(8, '0');
                }

                // Fill with pattern based on data (proper bit encoding)
                let bitIdx = 0;
                let moduleIdx = 0;
                
                for (let y = 0; y < this.moduleCount; y++) {
                    for (let x = 0; x < this.moduleCount; x++) {
                        let colorIndex = 0;
                        
                        if (bitIdx < bitString.length) {
                            // Extract bits for this module
                            const bits = bitString.substr(bitIdx, Math.floor(bitsPerModule));
                            colorIndex = parseInt(bits.padEnd(Math.floor(bitsPerModule), '0'), 2);
                            bitIdx += Math.floor(bitsPerModule);
                        }
                        
                        const [r, g, b] = colorRGB[colorIndex % this.colors.length];
                        
                        // Fill module (moduleSize x moduleSize block)
                        for (let dy = 0; dy < moduleSize; dy++) {
                            for (let dx = 0; dx < moduleSize; dx++) {
                                const pixelX = x * moduleSize + dx;
                                const pixelY = y * moduleSize + dy;
                                const pixelIndex = (pixelY * canvas.width + pixelX) * 4;
                                
                                pixels[pixelIndex] = r;
                                pixels[pixelIndex + 1] = g;
                                pixels[pixelIndex + 2] = b;
                                pixels[pixelIndex + 3] = 255; // Alpha
                            }
                        }
                        moduleIdx++;
                    }
                }

                // Put the image data on canvas
                ctx.putImageData(imageData, 0, 0);
                
                console.log(`üé® Created source canvas: ${canvas.width}x${canvas.height}, ImageData: ${imageData.width}x${imageData.height}`);

                // Add finder patterns (after pixel data)
                this.addFinderPatterns(ctx, moduleSize);

                // Add frame info with metadata
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 14px monospace';
                ctx.fillText(`F:${frameId}/${totalFrames} L:${data.length}`, 10, canvas.height - 10);

                return canvas;
            }

            addFinderPatterns(ctx, moduleSize) {
                const patternSize = 10 * moduleSize;
                const positions = [
                    [0, 0],
                    [this.moduleCount * moduleSize - patternSize, 0],
                    [0, this.moduleCount * moduleSize - patternSize]
                ];

                positions.forEach(([x, y]) => {
                    // Outer square
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x, y, patternSize, patternSize);
                    
                    // Inner square
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(x + moduleSize * 2, y + moduleSize * 2, patternSize - moduleSize * 4, patternSize - moduleSize * 4);
                    
                    // Center
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x + moduleSize * 4, y + moduleSize * 4, moduleSize * 2, moduleSize * 2);
                });
            }

            // Helper method to encode binary data to canvas (used by control frames)
            encodeDataToCanvas(binaryString, isControlFrame = false) {
                const canvas = document.createElement('canvas');
                const moduleSize = 4;
                canvas.width = this.moduleCount * moduleSize;
                canvas.height = this.moduleCount * moduleSize;
                const ctx = canvas.getContext('2d');

                // White background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Use ImageData for pixel manipulation
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const pixels = imageData.data;

                // Pre-convert colors to RGB
                const colorRGB = this.colors.map(c => {
                    const r = parseInt(c.substr(1, 2), 16);
                    const g = parseInt(c.substr(3, 2), 16);
                    const b = parseInt(c.substr(5, 2), 16);
                    return [r, g, b];
                });

                const bitsPerModule = Math.log2(this.colors.length);
                let bitIdx = 0;
                
                for (let y = 0; y < this.moduleCount; y++) {
                    for (let x = 0; x < this.moduleCount; x++) {
                        let colorIndex = 0;
                        
                        if (bitIdx < binaryString.length) {
                            const bits = binaryString.substr(bitIdx, Math.floor(bitsPerModule));
                            colorIndex = parseInt(bits.padEnd(Math.floor(bitsPerModule), '0'), 2);
                            bitIdx += Math.floor(bitsPerModule);
                        }
                        
                        const [r, g, b] = colorRGB[colorIndex % this.colors.length];
                        
                        for (let dy = 0; dy < moduleSize; dy++) {
                            for (let dx = 0; dx < moduleSize; dx++) {
                                const pixelX = x * moduleSize + dx;
                                const pixelY = y * moduleSize + dy;
                                const pixelIndex = (pixelY * canvas.width + pixelX) * 4;
                                
                                pixels[pixelIndex] = r;
                                pixels[pixelIndex + 1] = g;
                                pixels[pixelIndex + 2] = b;
                                pixels[pixelIndex + 3] = 255;
                            }
                        }
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                this.addFinderPatterns(ctx, moduleSize);

                // Add red corner marker for control frames
                if (isControlFrame) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(canvas.width - 12, canvas.height - 12, 12, 12);
                }

                return canvas;
            }

            // Create metadata frame with transfer info (QR-encoded)
            encodeMetadataFrame(filename, filesize, totalDataFrames) {
                // Create a special data packet with metadata
                // Format: "META" (4 bytes) + frame count (4 bytes) + filename length (2 bytes) + filename
                const encoder = new TextEncoder();
                const filenameBytes = encoder.encode(filename);
                
                const metadataSize = 4 + 4 + 2 + filenameBytes.length;
                const metadataArray = new Uint8Array(metadataSize);
                
                // Magic header "META"
                metadataArray[0] = 77;  // 'M'
                metadataArray[1] = 69;  // 'E'
                metadataArray[2] = 84;  // 'T'
                metadataArray[3] = 65;  // 'A'
                
                // Frame count (4 bytes, big-endian)
                metadataArray[4] = (totalDataFrames >> 24) & 0xFF;
                metadataArray[5] = (totalDataFrames >> 16) & 0xFF;
                metadataArray[6] = (totalDataFrames >> 8) & 0xFF;
                metadataArray[7] = totalDataFrames & 0xFF;
                
                // Filename length (2 bytes)
                metadataArray[8] = (filenameBytes.length >> 8) & 0xFF;
                metadataArray[9] = filenameBytes.length & 0xFF;
                
                // Filename bytes
                metadataArray.set(filenameBytes, 10);
                
                // Encode as binary string
                const binaryString = Array.from(metadataArray)
                    .map(byte => byte.toString(2).padStart(8, '0'))
                    .join('');
                
                // Create visual frame with special marker
                const canvas = this.encodeDataToCanvas(binaryString, true);
                return canvas;
            }

            // Create end-of-transfer frame (QR-encoded)
            encodeEndFrame(totalDataFrames) {
                // Create a special data packet with end marker
                // Format: "END!" (4 bytes) + frame count (4 bytes)
                const endArray = new Uint8Array(8);
                
                // Magic header "END!"
                endArray[0] = 69;  // 'E'
                endArray[1] = 78;  // 'N'
                endArray[2] = 68;  // 'D'
                endArray[3] = 33;  // '!'
                
                // Frame count (4 bytes, big-endian)
                endArray[4] = (totalDataFrames >> 24) & 0xFF;
                endArray[5] = (totalDataFrames >> 16) & 0xFF;
                endArray[6] = (totalDataFrames >> 8) & 0xFF;
                endArray[7] = totalDataFrames & 0xFF;
                
                // Encode as binary string
                const binaryString = Array.from(endArray)
                    .map(byte => byte.toString(2).padStart(8, '0'))
                    .join('');
                
                // Create visual frame with special marker
                const canvas = this.encodeDataToCanvas(binaryString, true);
                return canvas;
            }
        }

        // Simple Audio Encoder for synchronization and metadata
        class SimpleAudioEncoder {
            constructor() {
                this.sampleRate = 44100; // Standard audio sample rate
                this.duration = 0.1; // 100ms beeps
                this.baseFreq = 1000; // 1 kHz base frequency
                this.audioContext = null;
            }

            async init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            // Generate sync beep for frame start
            async playFrameSync(frameId) {
                await this.init();
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                // Frequency encodes frame number (simple modulation)
                oscillator.frequency.value = this.baseFreq + (frameId % 10) * 100;
                oscillator.type = 'sine';
                
                // Quick beep
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + this.duration);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + this.duration);
            }

            // Generate metadata announcement (filename, size)
            async playMetadata(filename, filesize, totalFrames) {
                await this.init();
                
                // Play a distinctive triple beep pattern
                const beeps = [800, 1200, 1600]; // Low-Mid-High frequency pattern
                
                for (let i = 0; i < beeps.length; i++) {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.frequency.value = beeps[i];
                    oscillator.type = 'sine';
                    
                    const startTime = this.audioContext.currentTime + (i * 0.15);
                    gainNode.gain.setValueAtTime(0.15, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.1);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + 0.1);
                }
            }

            // Generate end-of-transfer signal
            async playEndSignal() {
                await this.init();
                
                // Play descending tone
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.frequency.setValueAtTime(1500, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.3);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.3);
            }
        }

        // App state
        let selectedFile = null;
        let isTransferring = false;
        let isPaused = false;
        let currentFrame = 0;
        let frames = [];
        let transferInterval = null;
        let startTime = null;
        let audioEncoder = null;
        let loopCount = 0; // Track number of complete loops

        // Elements
        const uploadSection = document.getElementById('uploadSection');
        const fileInput = document.getElementById('fileInput');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const displayArea = document.getElementById('displayArea');
        const qrDisplay = document.getElementById('qrDisplay');
        const stats = document.getElementById('stats');
        const audioChannelCheckbox = document.getElementById('audioChannel');
        const loopModeCheckbox = document.getElementById('loopMode');

        // File selection
        uploadSection.addEventListener('click', () => fileInput.click());
        
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFileSelect(file);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFileSelect(file);
        });

        function handleFileSelect(file) {
            selectedFile = file;
            
            // Check file size and warn if too large
            const maxRecommendedSize = 100 * 1024; // 100 KB
            const maxSize = 500 * 1024; // 500 KB hard limit
            
            if (file.size > maxSize) {
                alert(`‚ö†Ô∏è File too large! Maximum size is 500 KB.\n\nYour file: ${formatFileSize(file.size)}\n\nPlease choose a smaller file or compress it.`);
                selectedFile = null;
                startBtn.disabled = true;
                return;
            }
            
            if (file.size > maxRecommendedSize) {
                const proceed = confirm(`‚ö†Ô∏è Large file warning!\n\nFile size: ${formatFileSize(file.size)}\nRecommended: < 100 KB\n\nEncoding may take a while and consume significant CPU.\n\nContinue anyway?`);
                if (!proceed) {
                    selectedFile = null;
                    startBtn.disabled = true;
                    return;
                }
            }
            
            startBtn.disabled = false;
            uploadSection.querySelector('h2').textContent = `‚úì ${file.name} (${formatFileSize(file.size)})`;
            document.getElementById('fileSize').textContent = formatFileSize(file.size);
            stats.classList.add('active');
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // Start transfer
        startBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

            const mode = document.getElementById('encodingMode').value;
            const ecc = parseFloat(document.getElementById('errorCorrection').value);
            const fps = parseInt(document.getElementById('frameRate').value);

            // Show progress indicator
            startBtn.textContent = 'Encoding...';
            startBtn.disabled = true;

            // Read file
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    // Convert ArrayBuffer to Uint8Array for proper binary handling
                    const arrayBuffer = e.target.result;
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    // Encode frames with chunked processing to prevent timeout
                    const encoder = new SimpleVisualEncoder(mode, ecc);
                    const chunkSize = 300; // Reduced from 500 for faster encoding
                    const totalDataFrames = Math.ceil(uint8Array.length / chunkSize);
                    
                    frames = [];
                    
                    // Add metadata frame at the beginning
                    const metadataFrame = encoder.encodeMetadataFrame(
                        selectedFile.name,
                        selectedFile.size,
                        totalDataFrames
                    );
                    frames.push(metadataFrame);
                    
                    // Process data frames in batches to avoid blocking
                    const batchSize = 5; // Process 5 frames at a time
                    for (let i = 0; i < totalDataFrames; i += batchSize) {
                        const batchEnd = Math.min(i + batchSize, totalDataFrames);
                        
                        // Process batch
                        for (let j = i; j < batchEnd; j++) {
                            const start = j * chunkSize;
                            const end = Math.min(start + chunkSize, uint8Array.length);
                            const chunk = uint8Array.slice(start, end);
                            const canvas = encoder.encodeFrame(chunk, j, totalDataFrames);
                            frames.push(canvas);
                        }
                        
                        // Update progress
                        const progress = ((i + batchSize) / totalDataFrames * 100).toFixed(0);
                        startBtn.textContent = `Encoding... ${Math.min(progress, 100)}%`;
                        
                        // Yield to browser to prevent timeout (every batch)
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    // Add end frame
                    const endFrame = encoder.encodeEndFrame(totalDataFrames);
                    frames.push(endFrame);

                    document.getElementById('frameCount').textContent = frames.length;
                    startBtn.textContent = 'Start Transfer';
                    startBtn.disabled = false;
                    
                    // Initialize audio encoder if enabled
                    if (audioChannelCheckbox.checked) {
                        audioEncoder = new SimpleAudioEncoder();
                        await audioEncoder.init();
                        // Play metadata announcement
                        await audioEncoder.playMetadata(selectedFile.name, selectedFile.size, frames.length);
                    }
                    
                    // Start displaying
                    startTransfer(fps);
                } catch (error) {
                    console.error('Encoding error:', error);
                    alert('Failed to encode file. Try a smaller file or lower error correction.');
                    startBtn.textContent = 'Start Transfer';
                    startBtn.disabled = false;
                }
            };
            reader.readAsArrayBuffer(selectedFile); // Use ArrayBuffer for binary files
        });

        function startTransfer(fps) {
            isTransferring = true;
            isPaused = false;
            currentFrame = 0;
            loopCount = 0; // Reset loop counter
            startTime = Date.now();

            displayArea.classList.add('active');
            stats.classList.add('active');
            startBtn.disabled = true;

            const interval = 1000 / fps;
            const loopEnabled = loopModeCheckbox.checked;
            
            transferInterval = setInterval(() => {
                if (!isPaused && currentFrame < frames.length) {
                    displayFrame(frames[currentFrame]);
                    
                    // Play audio sync beep if enabled
                    if (audioEncoder && audioChannelCheckbox.checked) {
                        audioEncoder.playFrameSync(currentFrame);
                    }
                    
                    currentFrame++;
                    updateStats();
                } else if (currentFrame >= frames.length) {
                    if (loopEnabled) {
                        // Loop mode: restart from beginning
                        currentFrame = 0;
                        loopCount++;
                        console.log(`üîÑ Loop ${loopCount} completed - restarting transfer`);
                    } else {
                        // Single-shot mode: stop transfer
                        stopTransfer();
                    }
                }
            }, interval);
        }

        function displayFrame(canvas) {
            const ctx = qrDisplay.getContext('2d');
            
            // Get container dimensions (recalculate each time as layout may have changed)
            const container = qrDisplay.parentElement;
            const containerRect = container.getBoundingClientRect();
            
            // Use larger base size - prefer width over height since QR codes are square
            const availableWidth = Math.max(containerRect.width - 40, 400);
            const availableHeight = Math.max(window.innerHeight * 0.6, 400); // Use 60% of viewport minimum
            
            // Calculate scale to fill available space (up to 3x)
            const scaleX = availableWidth / canvas.width;
            const scaleY = availableHeight / canvas.height;
            const scale = Math.max(Math.min(scaleX, scaleY, 3), 1); // At least 1x, up to 3x
            
            const scaledWidth = Math.floor(canvas.width * scale);
            const scaledHeight = Math.floor(canvas.height * scale);
            
            console.log(`üìê Display: canvas ${canvas.width}x${canvas.height} ‚Üí display ${scaledWidth}x${scaledHeight} (${scale.toFixed(2)}x), container: ${Math.floor(containerRect.width)}x${Math.floor(containerRect.height)}`);
            
            // Set BOTH canvas pixel dimensions AND CSS dimensions
            // Canvas pixel dimensions (internal resolution)
            qrDisplay.width = scaledWidth;
            qrDisplay.height = scaledHeight;
            
            // CSS dimensions (how browser displays it) - MUST match pixel dimensions!
            qrDisplay.style.width = `${scaledWidth}px`;
            qrDisplay.style.height = `${scaledHeight}px`;
            
            // AFTER setting size, check what the browser actually rendered
            const actualRect = qrDisplay.getBoundingClientRect();
            console.log(`üîç Actual canvas element: ${Math.floor(actualRect.width)}x${Math.floor(actualRect.height)} | CSS: ${qrDisplay.style.width} x ${qrDisplay.style.height}`);
            console.log(`üé® Source canvas: ${canvas.width}x${canvas.height}, Target canvas: ${qrDisplay.width}x${qrDisplay.height}`);
            
            // Fill with white background
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, scaledWidth, scaledHeight);
            
            // Draw scaled image with crisp pixels
            // Use 9-parameter version for explicit source->dest mapping
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;
            
            // drawImage(source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
            // Copy entire source (0,0,400,400) to entire dest (0,0,556,556)
            ctx.drawImage(
                canvas,           // source canvas
                0, 0,            // source x, y
                canvas.width,    // source width (400)
                canvas.height,   // source height (400)
                0, 0,            // dest x, y
                scaledWidth,     // dest width (556)
                scaledHeight     // dest height (556)
            );
            
            console.log(`‚úÖ Drew image from source(0,0,${canvas.width},${canvas.height}) to dest(0,0,${scaledWidth},${scaledHeight})`);
        }

        function updateStats() {
            const elapsed = (Date.now() - startTime) / 1000;
            const progress = (currentFrame / frames.length) * 100;
            const throughput = (selectedFile.size / elapsed) / 1024;

            document.getElementById('progress').textContent = progress.toFixed(1) + '%';
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('throughput').textContent = throughput.toFixed(1) + ' KB/s';
            document.getElementById('loopCounter').textContent = loopCount;
        }

        pauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? '‚ñ∂ Resume' : '‚è∏ Pause';
        });

        stopBtn.addEventListener('click', stopTransfer);

        function stopTransfer() {
            if (transferInterval) {
                clearInterval(transferInterval);
                transferInterval = null;
            }
            
            // Play end signal if audio is enabled and transfer completed
            if (audioEncoder && audioChannelCheckbox.checked && currentFrame >= frames.length) {
                audioEncoder.playEndSignal();
            }
            
            isTransferring = false;
            startBtn.disabled = false;
            pauseBtn.textContent = '‚è∏ Pause';
        }
    </script>
</body>
</html>
